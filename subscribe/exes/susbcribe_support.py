#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.22
#  in conjunction with Tcl version 8.6
#    May 30, 2019 09:39:38 PM CST  platform: Windows NT

import sys
import time
import paho.mqtt.client
from threading import Thread
mqtt = paho.mqtt.client

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    global vartext_port
    vartext_port = tk.StringVar(value=1883)
    global vartext_username
    vartext_username = tk.StringVar(value='admin')
    global vartext_password
    vartext_password = tk.StringVar(value='123456')
    global vartext_qos
    vartext_qos = tk.StringVar(value=0)
    global vartext_ip
    vartext_ip = tk.StringVar(value='47.93.30.53')
    global vartext_topic
    vartext_topic = tk.StringVar(value='/data/#')

def btn_停止订阅被单击():
    client.disconnect()
    client.loop_stop()
    print("已停止订阅并断开与服务器的连接")
    w.Scrolledtext1.insert(tk.END, "已停止订阅并断开与服务器的连接\n")
    w.TButton1.configure(state=tk.TRUE)
    w.TButton2.configure(state=tk.DISABLED)
def btn_开始订阅被单击():
    ip = vartext_ip.get()
    port = int(vartext_port.get())
    username = vartext_username.get()
    pwd = vartext_password.get()
    qos = int(vartext_qos.get())
    topic = vartext_topic.get()
    dict = {"ip": ip, "port": port, "username": username, "pwd": pwd, "qos": qos,"topic":topic}
    print(dict)
    w.Scrolledtext1.insert(tk.END, "{}\n".format(dict))
    if ip != "" and port != "" and username != "" and pwd != "" and qos != "" and topic != "":
        print("订阅设置格式验证完毕，开始尝试连接...")
        w.Scrolledtext1.insert(tk.END,"订阅设置格式验证完毕，开始尝试连接...\n")
        start_connect(ip,port,username,pwd,qos,topic)
    else:
        print("订阅设置有误，请检查后重试！")
        w.Scrolledtext1.insert(tk.END, "订阅设置有误，请检查后重试！\n")

def thread_it(func,*args):
    t = Thread(target=func, args=args)
    t.setDaemon(True)
    t.start()

def start_connect(ip="47.93.30.53",port=1883,username="admin",pwd="123456",qos=0,topic="/data/#"):
    client_id = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
    global client
    client = mqtt.Client(client_id,transport='tcp')  # ClientId不能重复，所以使用当前时间。连接方式参数为tcp也可以不写
    client.username_pw_set(username, pwd)  # 初始化订阅用户和密码 必须设置，否则会返回「Connected with result code 4」
    client.on_connect = on_connect  # 打印连接状态
    client.connect(ip, port, 60)  # 开始连接
    on_subscribe(topic, qos)  # 初始化订阅内容
    global xc1
    xc1 = Thread(target=client.loop_forever) #开启客户端阻塞线程
    xc1.setDaemon(True)
    xc1.start() #线程启动
    # global xc2
    # xc2 = Thread(target=sendtest) #循环发送消息。
    # xc2.setDaemon(True)
    # xc2.start()
def on_connect(client, userdata, flags, rc):#连接初始化函数。连接成功立即开始订阅并启动消息回调函数
    print("Connected with result code "+str(rc)) #打印连接状态
    w.Scrolledtext1.insert(tk.END, "Connected with result code %s \n"%str(rc))
    if rc == 0:
        print("已成功连接mqtt服务器!")
        w.Scrolledtext1.insert(tk.END, "已成功连接mqtt服务器!\n")
        w.TButton1.configure(state=tk.DISABLED)
        w.TButton2.configure(state=tk.TRUE)
    else:
        print("连接失败，请检查订阅设置是否正确!")
        w.Scrolledtext1.insert(tk.END, "连接失败，请检查订阅设置是否正确!\n")

def on_publish(topic, payload, qos):#发送函数
    """
    :param topic: 消息主题
    :param payload: 消息内容
    :param qos: 连接质量
    :return:
    """
    client.publish(topic, payload, qos)
def on_subscribe(topic="/data/#",qos=0): #订阅函数
    client.subscribe(topic,qos)  # 订阅通常的
    client.on_message = on_message  # 消息到来处理函数
    print("成功订阅主题: \"%s\",服务质量: %s"%(topic,qos))
    w.Scrolledtext1.insert(tk.END, "成功订阅主题: \"%s\",服务质量: %s \n"%(topic,qos))

def on_message(client, userdata, msg):#订阅消息收到后的回调函数
    msg_display = msg.payload.decode('utf-8')
    print("收到一条来自订阅主题 %s 的信息:    %s"%(msg.topic,msg_display)) #打印接受的消息
    w.Scrolledtext1.insert(tk.END, "收到一条来自订阅主题 %s 的信息:    %s\n"%(msg.topic,msg_display))

def sendtest():
    count = 0
    while True:
        on_publish("/data/message", "hello admin!这是第%d次发送消息" % count, 0)
        print(count)
        count += 1
        time.sleep(1)

def init(top, gui, *args, **kwargs):
    global w, top_level, root,client,xc1,xc2
    w = gui
    top_level = top
    root = top
    w.TButton1.configure(state=tk.TRUE)
    w.TButton2.configure(state=tk.DISABLED)


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import 订阅端
    订阅端.vp_start_gui()





